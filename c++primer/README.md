## 第三章 标准库类型实践及延伸
1. emplace_back 比直接的 push_back 快， 前者使用移动构造函数，比后者的拷贝函数少了许多开辟重新申请内存的操作 。

2. 右值

    1. 右值分为纯右值以及将亡值
        1. 纯右值即 C++98 标准中右值的概念：等号右边的为右值， 更为广泛的是能取地址的是左值，不能取地址的是右值。
        2. 将亡值则是 C++11 标准中的概念：C++11 新增的右值引用相关的表达式， 这种表达式通常是将要被移动的对象，例如 返回右值引用 T&& 的函数返回值， std::move 的返回值。

    2. 在无移动语义之前， 如果一个对象 a 赋值到另一个对象 b 的过程是将该对象的数据成员都重新构造一边赋值给 b。 假如 a 在赋值过后就不使用了，那么就会调用析构函数被 a 所占用的对象全部销毁。这个动作看起来就像是 一个冰箱的食物转移到另一个冰箱，但我们不是把冰箱的食物拿过来放过去，而是买一份新的放进去，再把旧冰箱的食物销毁掉，可想而知如果旧冰箱的食物越多这样造成的浪费就会更多， 所以移动语义的出现就能让我们直接把食物转移过去，而不用去买新的。

    3. 当无声明移动构造函数时，编译器会隐式生成，不过其效果跟拷贝构造函数一样。

    4. 进行移动构造函数， 里面的数据成员也都应该支持移动构造函数， 不然其执行的依旧是拷贝构造函数， 会造成一定的性能损失，不过问题不大。

    5. 要注意使用移动构造函数后，将亡值尽量不要再使用，避免出现段错误。

    6. demo( const demo&& d) 这样的移动构造函数没有意义， 因为 d 是个常量右值引用，不允许修改。


3. 引用折叠规则

    1. 为了能完美转发，一个函数接受 右值引用 和 左值引用，加入引用折叠规则。能根据 forward 转换出原始类型的引用。
    
    2. 如果不加入引用折叠的话，一个函数无法同时处理 2 种引用类型。即无法实现完美转发。
    
    3. 推到规则，存在左值引用即为左值引用类型，同时为右值引用才为右值引用类型。
    

| TR的类型定义 | 声明v的类型 | v的实际类型 |
|:-- |:-- |:--|
| T & | TR  | T & |
| T & | TR & | T & |
| T & | TR && | T & |
| T && | TR | T && |
| T && | TR & | T & |
| T && | TR && | T && |

## 第七章 函数实践及延伸

1. 函数返回值
    1. 千万不能返回局部变量的引用，因为函数结束时，该对象就会被释放。如果需要使用，可以用智能指针 shared_ptr 的方式, 它在引用指数为 0 时才会销毁对象。


| 类型 | 简介 | 共享 | 用途 |
|:-- |:-- |:-- |:-- |
| shared_ptr | 共享指针 | Y | 多指针共享同一个内存对象时，因为采用了引用计数的方式，所以只要有一个引用就不会被销毁 |
| weak_ptr | 弱指针 | Y | 它是 shared_ptr 的辅助指针，解决悬挂指针和循环引用问题。它指向 shared_ptr 的内存对象时不会增加 shared_ptr 的 count, 也就是它没有内存对象的声明控制权。它可以通过 lock 来判断 shared_ptr 对象是否还存活|
| unique_ptr | 唯一指针 | N | 只允许一个指针引用时，他不可以被隐式复制， 只能显示构造或者用 std::move 转移，但是原来的指针会变为 nullptr。 |

2. 函数重载
    1. 确定重载函数的步骤
        1. 候选函数: 根据函数名确定候选函数的集合。
        
        2. 选择可行函数: a. 函数参数个数相同。 b. 类型被隐式转换。
        
        3. 寻找最佳匹配: 实参类型与形参类型越接近越好, 例如 void testoverload(int i) 与 void testoverload(double i, double j = 0), 执行 testoverload(5.6) 时会优先匹配后者。如果还出现一个 void testoverload(float i) 则会报 ambiguous 的错误。
        
        4. 含多个形参的重载确定: a. 每个实参的匹配都不劣于其他可行函数需要的匹配。b. 至少有一个实参的匹配优于其他可行函数提供的匹配。  如果 2 个可行函数的匹配优先度是一样的，则会报 ambiguous 的错误。
    
    2. 局部地声明一个函数，则该函数会屏蔽外层作用域中声明的同名函数，而不是重载它。
    
    3. 当出现父子类为形参时， 子类优先匹配子类类型的函数(即没有子类函数时，匹配父类函数)， 父类只会匹配父类类型的函数(即没有父类函数时会报错)

    4. 父子类之间的转换
        1. 子类对象都包含一个父类部分，也就是操作子类可以像操作父类那样。因此存在子类型的引用到父类型的引用的自动转换。而父类可以是一个独立的存在，也可以是子类的一部分，所以不存在父类到子类的自动转换。( 可以理解为声明一个子类就声明了一个父类， 但是声明一个父类不一定声明一个子类)

        2. 引用转换与对象转换是不同的
            1. 对象引用转换是直接绑定的，看起来是传递了对象， 但实际上操作的还是对原对象的引用。引用转换不会修改子类型对象，对象依旧是子类型对象

            2. 对象转换实际上是一个子类型对象的父类部分被复制了。它的数据成员的值会被复制到基类， 但函数不会，即使是虚函数。 即只是正常的调用了拷贝构造函数。

3. const 修饰成员函数， 经 const 修饰的成员函数不能引用非 const 成员函数， 以及不能修改任何数据成员。
            
4. 函数指针
    1. 引用函数名相当于在函数名上应用取地址符，也就是 auto ptr = function 与 auto ptr = &function 等效。
    
5. 形参为数组引用时，数组不能转换成指针类型。
    
    
## 第八章 标准 IO 库实践

1. 文中 cin.clear(istream::fail) 的写法是错误的，clear 是用传入的值覆盖当前的值， 不是清除传入的值。 如果将 fail 的错误位清除正确写法是 cin.clear( ~istream::fail && cin.rdstate());

## 第九章 顺序容器实践及扩展

1. 临时变量是 const 变量。

2. 不同容器不同元素类型能通过 iterator 来直接复制。

## 第十二章 类实践及扩展

1. static 关键字
    1. static 作为静态对象
        1. 对象一旦创建在程序结束前不会销毁，即使是局部对象( 虽然不会销毁，但只能在声明的作用域内使用 )。
    
        2. 无法与其他源文件共享，即使用 extern 声明。
    
    1. static 作为类成员
        1. 它是类成员，不是对象成员，没有 this 指针，并且不能直接访问对象成员。
        
        2. 不能定义静态成员函数为虚函数， 它是一个全局函数， 定义虚函数没有意义。
        
        3. 静态变量是基类和派生类共享的，共用空间的。但收访问控制限制。
        
        4. 不能在类中初始化，除非是 const 类型。 因为初始化必定要分配内存，而类的定义只是声明而已，如果等待类实例化再分配内存，那如果多次实例化呢。这样会出现重复。
        
## 第十三章 复制控制实践及扩展

1. 拷贝构造函数与赋值操作符区别
    1. 前者用于初始化另一个对象，即一个对象不存在， 后者用于赋值，2 个对象都已存在。(ps: base b2 = b; 用的是拷贝构造函数，因为此时 b2 还未存在，需要用 b 去初始化)

2. 在执行对指针的复制之后， 因为此时实际上复制的是对象的地址，所以当 2 个类任意一个对象被销毁都可能造成悬挂指针， 所以引入计数， 当指针引用为 0 时， 指针指向的对象才会被销毁， 避免悬挂指针， 也就是使用智能指针， 这里在第七章有扩展到。
      
3. 调用析构后，该对象依旧可以被使用，因为此时堆中的内存对象还没被回收， 但此时他是危险的，不可预知的。

## 第十四章 重载操作符与转换实践及扩展

1. 具有内置含义的操作符一般情况下不要重载。

2. 操作运算符返回右值， 而赋值运算符应返回引用， 减少创建和撤销结果产生的不必要消耗。

## 第十五章 面向对象编程实践及扩展

1. 动态绑定不依赖对象，而依赖引用与指针。

2. 派生类与基类的转换
    1. 基类引用或指针不能自动转换为派生类引用或指针， 在已知转换是安全的情况下可以使用 static_cast 或者 dynamic_cast 转换。
    
    2. 派生类引用或指针可以自动转换为基类引用或指针。
    
    3. 结合 1,2 内容可知，派生类引用(指针)在转换成基类引用(指针)，可以重新从基类引用(指针)再次转换为派生类引用(指针)。
    
    4. 派生类对象可以为基类对象赋值或初始化， 但基类对象不能为派生类对象做赋值或初始化。基类对象只能是基类对象。
    
3. 基类与派生类存在成员函数相同但形参不同时， 派生类成员函数会屏蔽掉基类成员函数， 并且派生类转换成基类引用(指针)时，无法调用同名的派生类成员函数。
    1. 需要在引用基类重载的成员函数时， 可以用 using , 把重载版本全都继承到派生类。
    
    2. 可以人为的增加一个类， 继承派生类，并且定义基类和派生类 2 个重载版本。 但还是无法从派生类转换成的基类引用调用派生类的同名成员函数。 需要借助第三个类。
    
## 第十六章 模板与泛型编程实践及扩展
1. typename 和 class 具有相同的含义，可以互换使用。 但后面为内置类型时应该使用 typename, 为类类型时应使用 class, 这并非 2 个关键字的用法不同， 而是增加代码的可读性。

2. 当使用模板类的类型成员时， 需显示声明。 例如 T::size_type, 编译器无法确定它是一个类型成员还是数据成员， 会默认当成数据成员， 所以需要显示处理，写成 typename T::size_type 。

3. 模板形参并非都是类型， 也可以为常量， 值类型在模板形参表指定就行。例如 template < int N > 。

4. 通常，使用类模板名字时应指定模板形参，但在类本身的作用域内部，可以直接使用类模板的非限定名，例如 Queue<Type> 类内部， Queue 等价于 Queue<Type> 。

5. 若想限制对特定实例化模板的友元关系时，必须在使用有缘之前声明该模板类或模板函数。

6. 重载与函数模板的匹配规则
    1. 优先匹配参数类型对应的函数。
    
    2. 根据转转的种类排列可行函数。 例如 test(T&t, T& t2), 与普通函数 test(const char* t, const char* t2), 而 char ch_arr[2],ch_arr2[2],test(ch_arr,ch_arr2) , 第一个精准匹配， 无需转换， 而第二个需要从 char* 转换成 const char*， 则优先选择第一个。
    
    3. 当转换优先度一样时，优先选择普通函数，而非模板函数。
    
## 第十七章 用于大型程序的工具实践及扩展
1. 析构函数应保证不会抛去异常，不然很容易导致二次异常抛出，直接调用 terminal 函数，直接结束程序。

2. 派生类虚函数的异常说明范围不能超过基类虚函数的异常说明。

3. 当一个基类在派生层次出现多次时， 需要共享时，应使用虚继承，并且避免出现二义性问题。

4. 虚继承时，共享基类会在最低派生层次初始化，其他层次出现的初始化将会被忽略。

5. 多继承情况下， 构造函数的初始化次序跟析构函数的调用次序相反。

## 第十八章 特殊工具与技术
1. allocate 分配类型化的内存，则它不必计算字节来分配内存。( allocate 底层实际也是用 operator new 来分配内存)。
 
2. operator new 分配 void* 形式的内存，则它需要计算所需字节来分配内存。

3. construct 函数只能使用复制构造函数， 但在 C++11 中， 它可以使用任意构造函数。

4. operator new 和 operator delete 必须同时重载。