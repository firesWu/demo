## 第三章实践及延伸
1. emplace_back 比直接的 push_back 快， 前者使用移动构造函数，比后者的拷贝函数少了许多开辟重新申请内存的操作 。

2. 右值

    1. 右值分为纯右值以及将亡值
        1. 纯右值即 C++98 标准中右值的概念：等号右边的为右值， 更为广泛的是能取地址的是左值，不能取地址的是右值。
        2. 将亡值则是 C++11 标准中的概念：C++11 新增的右值引用相关的表达式， 这种表达式通常是将要被移动的对象，例如 返回右值引用 T&& 的函数返回值， std::move 的返回值。

    2. 在无移动语义之前， 如果一个对象 a 赋值到另一个对象 b 的过程是将该对象的数据成员都重新构造一边赋值给 b。 假如 a 在赋值过后就不使用了，那么就会调用析构函数被 a 所占用的对象全部销毁。这个动作看起来就像是 一个冰箱的食物转移到另一个冰箱，但我们不是把冰箱的食物拿过来放过去，而是买一份新的放进去，再把旧冰箱的食物销毁掉，可想而知如果旧冰箱的食物越多这样造成的浪费就会更多， 所以移动语义的出现就能让我们直接把食物转移过去，而不用去买新的。

    3. 当无声明移动构造函数时，编译器会隐式生成，不过其效果跟拷贝构造函数一样。

    4. 进行移动构造函数， 里面的数据成员也都应该支持移动构造函数， 不然其执行的依旧是拷贝构造函数， 会造成一定的性能损失，不过问题不大。

    5. 要注意使用移动构造函数后，将亡值尽量不要再使用，避免出现段错误。

    6. demo( const demo&& d) 这样的移动构造函数没有意义， 因为 d 是个常量右值引用，不允许修改。


3. 引用折叠规则

    1. 为了能完美转发，一个函数接受 右值引用 和 左值引用，加入引用折叠规则。能根据 forward 转换出原始类型的引用。
    
    2. 如果不加入引用折叠的话，一个函数无法同时处理 2 种引用类型。即无法实现完美转发。
    
    3. 推到规则，存在左值引用即为左值引用类型，同时为右值引用才为右值引用类型。
    

| TR的类型定义 | 声明v的类型 | v的实际类型 |
|:-- |:-- |:--|
| T & | TR  | T & |
| T & | TR & | T & |
| T & | TR && | T & |
| T && | TR | T && |
| T && | TR & | T & |
| T && | TR && | T && |

<<<<<<< HEAD
    1. 为了能完美转发，一个函数接受 右值引用 和 左值引用，加入引用折叠规则。能根据 forward 转换出起原始类型的引用。
    2. 如果不加入引用折叠的话，一个函数无法同时处理 2 种引用类型。即无法实现完美转发。
    3. 推到规则，存在左值引用即为左值引用类型，同时为右值引用才为右值引用类型。

## 第七章实践及延伸

1. 函数返回值
    1. 千万不能返回局部变量的引用，因为函数结束时，该对象就会被释放。如果需要使用，可以用智能指针 shared_ptr 的方式, 它在引用指数为 0 时才会销毁对象。


| 类型 | 简介 | 共享 | 用途 |
| shared_ptr | 共享指针 | Y | 多指针共享同一个内存对象时，因为采用了引用计数的方式，所以只要有一个引用就不会被销毁 |
| weak_ptr | 弱指针 | Y | 它是 shared_ptr 的辅助指针，解决悬挂指针和循环引用问题。它指向 shared_ptr 的内存对象时不会增加 shared_ptr 的 count, 也就是它没有内存对象的声明控制权。它可以通过 lock 来判断 shared_ptr 对象是否还存活|
| unique_ptr | 唯一指针 | N | 只允许一个指针引用时，他不可以被隐式复制， 只能显示构造或者用 std::move 转移，但是原来的指针会变为 nullptr。 |


=======
    
>>>>>>> 810994cf67a50885947b2b81d1dc93fdbe84761e
